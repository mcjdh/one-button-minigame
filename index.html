<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>One Button Warrior</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            background: #1a0a0a;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: monospace;
        }
        #gameContainer {
            position: relative;
        }
        canvas {
            display: block;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        #startOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0,0,0,0.7);
            color: #fff;
            cursor: pointer;
        }
        #startOverlay h1 {
            font-size: 24px;
            margin-bottom: 20px;
            text-shadow: 2px 2px #000;
        }
        #startOverlay p {
            font-size: 14px;
            opacity: 0.8;
        }
        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="game" width="400" height="240"></canvas>
        <div id="startOverlay">
            <h1>ONE BUTTON WARRIOR</h1>
            <p style="color: #ffff00;">[!] TAP = Attack (single note)</p>
            <p style="color: #00ffff;">[1-2] DOUBLE-TAP = Block (two notes)</p>
            <p style="color: #4488ff;">[H━━] HOLD = Charge (long note)</p>
            <p style="margin-top: 15px; font-size: 12px; opacity: 0.7;">Watch the beat track - hit when markers reach the zone!</p>
            <p style="margin-top: 10px; opacity: 0.6;">Click or press SPACE to start</p>
        </div>
    </div>

    <script>
// ============================================
// ONE BUTTON WARRIOR - Game Jam Edition
// ============================================

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const startOverlay = document.getElementById('startOverlay');

// Scale canvas for crisp pixels
const SCALE = 2;
canvas.style.width = canvas.width * SCALE + 'px';
canvas.style.height = canvas.height * SCALE + 'px';

// ============================================
// AUDIO ENGINE (Web Audio API)
// ============================================
let audioCtx = null;
let masterGain = null;
let bpm = 52; // Start nice and slow for readability
let beatInterval = 60 / bpm;
let nextBeatTime = 0;
let currentBeat = 0; // 0-3 for the 4-beat cycle

// Note frequencies (pentatonic scale in C)
const NOTES = {
    C3: 130.81, D3: 146.83, E3: 164.81, G3: 196.00, A3: 220.00,
    C4: 261.63, D4: 293.66, E4: 329.63, G4: 392.00, A4: 440.00,
    C5: 523.25, D5: 587.33, E5: 659.25, G5: 783.99, A5: 880.00
};

// Chord progression: I - V - vi - IV (C - G - Am - F)
const CHORD_ROOTS = [NOTES.C3, NOTES.G3, NOTES.A3, NOTES.C3]; // Simplified

function initAudio() {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    masterGain = audioCtx.createGain();
    masterGain.gain.value = 0.3;
    masterGain.connect(audioCtx.destination);
    nextBeatTime = audioCtx.currentTime + 0.1;
}

// Create a simple oscillator for chiptune sounds
function playTone(freq, duration, type = 'square', volume = 0.3, startTime = null) {
    if (!audioCtx) return;
    const start = startTime || audioCtx.currentTime;

    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();

    osc.type = type;
    osc.frequency.value = freq;

    gain.gain.setValueAtTime(volume, start);
    gain.gain.exponentialRampToValueAtTime(0.001, start + duration);

    osc.connect(gain);
    gain.connect(masterGain);

    osc.start(start);
    osc.stop(start + duration);
}

// Kick drum - low frequency burst
function playKick(time) {
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();

    osc.type = 'sine';
    osc.frequency.setValueAtTime(150, time);
    osc.frequency.exponentialRampToValueAtTime(30, time + 0.1);

    gain.gain.setValueAtTime(0.8, time);
    gain.gain.exponentialRampToValueAtTime(0.001, time + 0.15);

    osc.connect(gain);
    gain.connect(masterGain);

    osc.start(time);
    osc.stop(time + 0.15);
}

// Snare/hi-hat - noise burst
function playSnare(time) {
    const bufferSize = audioCtx.sampleRate * 0.1;
    const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
    const data = buffer.getChannelData(0);

    for (let i = 0; i < bufferSize; i++) {
        data[i] = Math.random() * 2 - 1;
    }

    const noise = audioCtx.createBufferSource();
    noise.buffer = buffer;

    const gain = audioCtx.createGain();
    gain.gain.setValueAtTime(0.3, time);
    gain.gain.exponentialRampToValueAtTime(0.001, time + 0.08);

    // High-pass filter for snare character
    const filter = audioCtx.createBiquadFilter();
    filter.type = 'highpass';
    filter.frequency.value = 1000;

    noise.connect(filter);
    filter.connect(gain);
    gain.connect(masterGain);

    noise.start(time);
    noise.stop(time + 0.1);
}

// Bass note
function playBass(freq, time) {
    playTone(freq, beatInterval * 0.8, 'triangle', 0.4, time);
}

// Lead melody note
function playLead(freq, time, duration = 0.15) {
    playTone(freq, duration, 'square', 0.15, time);
}

// Schedule a beat's audio with DYNAMIC LAYERS
function scheduleBeat(beatNum, time) {
    // Trigger visual beat pulse
    beatPulse = 1;

    // LAYER 1: Drums - always playing (kick on 1 & 3, snare on 2 & 4)
    if (beatNum === 0 || beatNum === 2) {
        playKick(time);
    } else {
        playSnare(time);
    }

    // Extra hi-hat on every beat when combo 5+
    if (player.combo >= 5) {
        playTone(8000, 0.03, 'square', 0.1, time);
    }

    // LAYER 2: Bass follows chord progression
    const chordIndex = Math.floor(currentBar % 4);
    playBass(CHORD_ROOTS[chordIndex], time);

    // LAYER 3: Lead melody - procedural pentatonic (plays more often at higher combo)
    if (gameState === 'playing') {
        const pentatonic = player.feverMode ?
            [NOTES.C5, NOTES.D5, NOTES.E5, NOTES.G5, NOTES.A5] : // Higher octave in fever
            [NOTES.C4, NOTES.D4, NOTES.E4, NOTES.G4, NOTES.A4, NOTES.C5];
        const playChance = 0.4 + Math.min(player.combo * 0.05, 0.4); // More notes at high combo
        if (Math.random() < playChance) {
            const noteIndex = Math.floor(Math.random() * pentatonic.length);
            playLead(pentatonic[noteIndex], time, beatInterval * 0.3);
        }
    }

    // LAYER 4: ARPEGGIO at combo 7+ (16th notes)
    if (player.combo >= 7 && gameState === 'playing') {
        const arpNotes = [NOTES.C4, NOTES.E4, NOTES.G4, NOTES.C5];
        const sixteenth = beatInterval / 4;
        for (let i = 0; i < 4; i++) {
            playTone(arpNotes[i], sixteenth * 0.8, 'square', 0.08, time + i * sixteenth);
        }
    }

    // LAYER 5: FEVER MODE - extra intensity!
    if (player.feverMode && gameState === 'playing') {
        // Pulsing bass octave
        playTone(CHORD_ROOTS[chordIndex] * 2, beatInterval * 0.2, 'sawtooth', 0.15, time);
        // Extra percussion flourish
        if (beatNum === 1 || beatNum === 3) {
            playTone(300, 0.05, 'square', 0.2, time);
            playTone(400, 0.05, 'square', 0.15, time + 0.05);
        }
    }
}

// SFX
function playSFX(type) {
    if (!audioCtx) return;
    const now = audioCtx.currentTime;

    switch(type) {
        case 'attack':
            // Quick rising pitch
            playTone(200, 0.1, 'sawtooth', 0.4);
            playTone(400, 0.1, 'sawtooth', 0.3);
            break;
        case 'block':
            // Metallic clang
            playTone(800, 0.15, 'square', 0.3);
            playTone(600, 0.1, 'square', 0.2);
            break;
        case 'hit':
            // Enemy hit
            playTone(300, 0.2, 'sawtooth', 0.5);
            playTone(150, 0.3, 'sawtooth', 0.3);
            break;
        case 'damage':
            // Descending wah
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(400, now);
            osc.frequency.exponentialRampToValueAtTime(100, now + 0.3);
            gain.gain.setValueAtTime(0.5, now);
            gain.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
            osc.connect(gain);
            gain.connect(masterGain);
            osc.start(now);
            osc.stop(now + 0.3);
            break;
        case 'crit':
            // Fanfare arpeggio
            playTone(NOTES.C5, 0.1, 'square', 0.3);
            playTone(NOTES.E5, 0.1, 'square', 0.3);
            setTimeout(() => playTone(NOTES.G5, 0.15, 'square', 0.4), 100);
            break;
        case 'graze':
            // Lucky dodge sound
            playTone(600, 0.05, 'sine', 0.2);
            playTone(800, 0.1, 'sine', 0.3);
            break;
        case 'charge':
            // Power-up charge sound
            playTone(150, 0.3, 'sawtooth', 0.5);
            playTone(300, 0.2, 'sawtooth', 0.4);
            setTimeout(() => playTone(600, 0.15, 'square', 0.3), 100);
            break;
        case 'smash':
            // Heavy impact
            playTone(80, 0.3, 'sawtooth', 0.6);
            playTone(60, 0.4, 'sine', 0.5);
            break;
        case 'miss':
            // Buzzer/error sound for missed timing
            playTone(150, 0.15, 'square', 0.4);
            playTone(100, 0.2, 'square', 0.3);
            break;
        case 'fever':
            // Fever mode activation fanfare
            playTone(NOTES.C5, 0.1, 'square', 0.4);
            setTimeout(() => playTone(NOTES.E5, 0.1, 'square', 0.4), 80);
            setTimeout(() => playTone(NOTES.G5, 0.1, 'square', 0.4), 160);
            setTimeout(() => playTone(NOTES.C5 * 2, 0.2, 'square', 0.5), 240);
            break;
    }
}

// ============================================
// GAME STATE
// ============================================
let gameState = 'title'; // 'title', 'playing', 'gameover'
let currentBar = 0;
let phase = 0; // 0-3: enemy appears, choose, clash, aftermath

// Player state
let player = {
    stance: 'idle', // 'idle', 'aggressive', 'defensive', 'stumble'
    lives: 3,
    score: 0,
    combo: 0,
    hasSeenArmored: false,
    feverMode: false
};

// Current enemy
let enemy = null;
let enemyQueue = [];

// Input state
let inputBuffer = [];
let lastTapTime = 0;
let holdStartTime = 0;
let isHolding = false;
let chargeLevel = 0; // 0-1, for visual feedback
const DOUBLE_TAP_WINDOW = 200; // ms
const BEAT_WINDOW = 300; // ms - forgiving timing
const HOLD_THRESHOLD = 400; // ms to trigger charge attack

// High score
let highScore = parseInt(localStorage.getItem('oneButtonWarriorHighScore')) || 0;

// Visual effects
let screenShake = 0;
let flashColor = null;
let flashAlpha = 0;
let particles = [];

// JUICE EFFECTS
let hitStop = 0; // Freeze frames on big hits
let chromaOffset = 0; // Chromatic aberration on hits
let slowMo = 1; // Slow motion multiplier (1 = normal)
let comboMilestone = 0; // For milestone celebrations
let lastComboMilestone = 0;

// Kill text variety
const KILL_TEXTS = ['SLAIN!', 'DESTROYED!', 'VANQUISHED!', 'OBLITERATED!', 'WRECKED!'];
const CRIT_TEXTS = ['CRITICAL!', 'DEVASTATING!', 'BRUTAL!', 'SAVAGE!'];
const OVERKILL_TEXTS = ['OVERKILL!', 'ANNIHILATED!', 'DECIMATED!', 'EVISCERATED!'];

// WarioWare-style prompt
let bigPrompt = '';
let bigPromptColor = '#ffffff';
let bigPromptScale = 1;
let bigPromptAlpha = 0;

// Beat pulse for visual rhythm feedback
let beatPulse = 0;

// Guitar Hero style beat markers
let beatMarkers = [];
let hitZoneX = 80; // Where you should hit

// ============================================
// ENEMY SYSTEM
// ============================================
const ENEMY_TYPES = {
    swordsman: { color: '#ff4444', eyes: '#ff0000', weapon: 'sword', counter: 'aggressive' },
    archer: { color: '#44ff44', eyes: '#00ff00', weapon: 'bow', counter: 'defensive' },
    armored: { color: '#4488ff', eyes: '#0066ff', weapon: 'shield', counter: 'charge' }
};

function spawnEnemy() {
    // Introduce armored earlier (after score 200) so players experience charge mechanic
    let types = ['swordsman', 'archer'];
    if (player.score >= 200) {
        types.push('armored');
    }
    // Guarantee first armored around bar 8 to teach the mechanic
    if (currentBar >= 8 && currentBar < 12 && !player.hasSeenArmored) {
        types = ['armored'];
        player.hasSeenArmored = true;
    }
    const type = types[Math.floor(Math.random() * types.length)];
    enemy = {
        type: type,
        ...ENEMY_TYPES[type],
        x: canvas.width + 50,
        targetX: canvas.width - 100,
        y: canvas.height - 80,
        alive: true,
        staggered: false
    };
}

// ============================================
// COMBAT RESOLUTION
// ============================================
function resolveClash() {
    if (!enemy || !enemy.alive) return;

    const stance = player.stance;
    const correct = stance === enemy.counter;

    // Dice roll for variance
    const roll = Math.random();

    if (stance === 'stumble') {
        // Stumble always takes damage (with graze chance)
        if (roll < 0.2) {
            // Graze!
            flashColor = '#ffff00';
            flashAlpha = 1;
            showText('GRAZE!', canvas.width/2, canvas.height/2 - 30, '#ffff00');
            playSFX('graze');
        } else {
            takeDamage();
        }
    } else if (correct) {
        // Correct stance - KILL with crit chance
        enemy.alive = false;
        player.combo++;

        // Fever mode = guaranteed crits!
        const feverBonus = player.feverMode ? 0.3 : 0; // Boost crit chance

        // Charge attacks are always powerful - MAX JUICE
        if (stance === 'charge') {
            player.score += 250;
            screenShake = 20;
            hitStop = 12; // FREEZE FRAME!
            chromaOffset = 8; // Chromatic aberration
            flashColor = '#4488ff';
            flashAlpha = 1;
            showText('SMASH!', canvas.width/2, canvas.height/2 - 30, '#4488ff');
            playSFX('smash');
            spawnParticles(enemy.x, enemy.y, 25, enemy.color);
            // Extra ground particles
            for (let i = 0; i < 10; i++) {
                particles.push({
                    x: enemy.x + (Math.random() - 0.5) * 60,
                    y: canvas.height - 45,
                    vx: (Math.random() - 0.5) * 4,
                    vy: -Math.random() * 5,
                    life: 1,
                    color: '#555555'
                });
            }
        } else if (roll < 0.1 + feverBonus) {
            // OVERKILL! (more likely in fever mode)
            player.score += 300;
            screenShake = 15;
            hitStop = 10; // FREEZE FRAME!
            chromaOffset = 6;
            flashColor = '#ff00ff';
            flashAlpha = 1;
            const killText = OVERKILL_TEXTS[Math.floor(Math.random() * OVERKILL_TEXTS.length)];
            showText(killText, canvas.width/2, canvas.height/2 - 30, '#ff00ff');
            playSFX('crit');
            spawnParticles(enemy.x, enemy.y, 20, enemy.color);
        } else if (roll < 0.3 + feverBonus || player.feverMode) {
            // Critical! (guaranteed in fever mode)
            player.score += 200;
            screenShake = 8;
            hitStop = 6; // Small freeze
            chromaOffset = 3;
            flashColor = player.feverMode ? '#ff00ff' : '#ffff00';
            flashAlpha = 0.5;
            const critText = player.feverMode ? 'FEVER CRIT!' : CRIT_TEXTS[Math.floor(Math.random() * CRIT_TEXTS.length)];
            showText(critText, canvas.width/2, canvas.height/2 - 30, player.feverMode ? '#ff00ff' : '#ffff00');
            playSFX('crit');
            spawnParticles(enemy.x, enemy.y, 15, player.feverMode ? '#ff00ff' : enemy.color);
        } else {
            // Normal kill - varied text
            player.score += 100 * (1 + Math.floor(player.combo / 5));
            const killText = KILL_TEXTS[Math.floor(Math.random() * KILL_TEXTS.length)];
            showText(killText, canvas.width/2, canvas.height/2 - 30, '#88ff88');
            playSFX('hit');
            spawnParticles(enemy.x, enemy.y, 10, enemy.color);
        }

        // Check combo milestones!
        checkComboMilestone();
    } else if (stance === 'defensive' && enemy.type === 'swordsman') {
        // Block - enemy survives
        if (roll < 0.1) {
            // Counter!
            enemy.alive = false;
            player.combo++;
            player.score += 150;
            showText('COUNTER!', canvas.width/2, canvas.height/2 - 30, '#00ffff');
            playSFX('crit');
            spawnParticles(enemy.x, enemy.y, 12, enemy.color);
        } else if (roll < 0.4) {
            // Staggered
            enemy.staggered = true;
            showText('BLOCKED!', canvas.width/2, canvas.height/2 - 30, '#888888');
            playSFX('block');
        } else {
            showText('BLOCKED', canvas.width/2, canvas.height/2 - 30, '#666666');
            playSFX('block');
        }
    } else if (stance === 'charge' && enemy.type !== 'armored') {
        // Charge attack overkill on non-armored (but wastes charge)
        enemy.alive = false;
        player.combo++;
        player.score += 150;
        screenShake = 12;
        showText('OVERKILL!', canvas.width/2, canvas.height/2 - 30, '#4488ff');
        playSFX('smash');
        spawnParticles(enemy.x, enemy.y, 18, enemy.color);
    } else {
        // Wrong stance - DAMAGE with graze chance
        if (roll < 0.2) {
            // Graze!
            flashColor = '#ffff00';
            flashAlpha = 0.5;
            showText('GRAZE!', canvas.width/2, canvas.height/2 - 30, '#ffff00');
            playSFX('graze');
        } else {
            takeDamage();
        }
    }
}

function takeDamage() {
    player.lives--;
    player.combo = 0;
    player.feverMode = false; // End fever mode on damage
    screenShake = 10;
    flashColor = '#ff0000';
    flashAlpha = 0.8;
    playSFX('damage');

    if (player.lives <= 0) {
        gameState = 'gameover';
        // Save high score
        if (player.score > highScore) {
            highScore = player.score;
            localStorage.setItem('oneButtonWarriorHighScore', highScore);
        }
    }
}

// ============================================
// INPUT HANDLING
// ============================================
function handleInputDown() {
    const now = performance.now();
    holdStartTime = now;
    isHolding = true;

    // Check for double tap
    if (now - lastTapTime < DOUBLE_TAP_WINDOW) {
        // Double tap - DEFENSIVE
        player.stance = 'defensive';
        playSFX('block');
        lastTapTime = 0;
        isHolding = false;
        markBeatHit('defensive');
    } else {
        lastTapTime = now;
        // Mark first marker of double-tap pair immediately for visual feedback
        // This shows the player their first tap registered
        const hitRange = 80;
        beatMarkers.forEach(marker => {
            const dist = Math.abs(marker.x - hitZoneX);
            if (!marker.hit && dist < hitRange && marker.type === 'defensive' && !marker.isSecond) {
                marker.hit = true;
                // Small feedback particles for first hit
                for (let i = 0; i < 6; i++) {
                    particles.push({
                        x: hitZoneX,
                        y: canvas.height - 35,
                        vx: (Math.random() - 0.5) * 6,
                        vy: (Math.random() - 0.5) * 6,
                        life: 0.5,
                        color: '#00ffff'
                    });
                }
            }
        });
    }
}

// Mark the closest beat marker as hit (for visual feedback)
function markBeatHit(actionType) {
    const hitRange = 80; // More forgiving range
    let bestMarker = null;
    let bestDist = Infinity;

    beatMarkers.forEach(marker => {
        const dist = Math.abs(marker.x - hitZoneX);
        if (!marker.hit && dist < hitRange && dist < bestDist) {
            bestMarker = marker;
            bestDist = dist;
        }
    });

    // Color based on action type
    const actionColors = {
        aggressive: '#ffff00',
        defensive: '#00ffff',
        charge: '#4488ff'
    };
    const pColor = actionColors[actionType] || '#ffffff';

    if (bestMarker) {
        bestMarker.hit = true;

        // For double-tap, mark BOTH markers as hit
        if (actionType === 'defensive') {
            beatMarkers.forEach(m => {
                if (m.type === 'defensive' && !m.hit && Math.abs(m.x - bestMarker.x) < 60) {
                    m.hit = true;
                }
            });
        }

        // Timing feedback
        let timingText, timingColor;
        if (bestDist < 20) {
            timingText = 'PERFECT!';
            timingColor = '#ffff00';
            screenShake = Math.max(screenShake, 3);
        } else if (bestDist < 45) {
            timingText = 'GREAT';
            timingColor = '#88ff88';
        } else {
            timingText = 'OK';
            timingColor = '#aaaaaa';
        }

        showText(timingText, hitZoneX, canvas.height - 55, timingColor);

        // Spawn hit particles
        for (let i = 0; i < 12; i++) {
            particles.push({
                x: hitZoneX,
                y: canvas.height - 35,
                vx: (Math.random() - 0.5) * 10,
                vy: (Math.random() - 0.5) * 10,
                life: 0.8,
                color: pColor
            });
        }
    } else {
        // No marker in range but still show some feedback
        for (let i = 0; i < 6; i++) {
            particles.push({
                x: hitZoneX,
                y: canvas.height - 35,
                vx: (Math.random() - 0.5) * 5,
                vy: (Math.random() - 0.5) * 5,
                life: 0.5,
                color: pColor
            });
        }
    }
}

function handleInputUp() {
    if (!isHolding) return;

    const now = performance.now();
    const holdDuration = now - holdStartTime;
    isHolding = false;

    // If we already set defensive (double-tap), don't override
    if (player.stance === 'defensive') return;

    if (holdDuration >= HOLD_THRESHOLD) {
        // CHARGE attack!
        player.stance = 'charge';
        playSFX('charge');
        markBeatHit('charge');
    } else {
        // Single tap - AGGRESSIVE
        player.stance = 'aggressive';
        playSFX('attack');
        markBeatHit('aggressive');
    }

    chargeLevel = 0;
}

// Update charge level each frame
function updateCharge() {
    if (isHolding) {
        const holdDuration = performance.now() - holdStartTime;
        chargeLevel = Math.min(1, holdDuration / HOLD_THRESHOLD);

        // Auto-trigger charge visual/sound when fully charged
        if (holdDuration >= HOLD_THRESHOLD && player.stance === 'idle') {
            player.stance = 'charge';
            playSFX('charge');
        }
    } else if (chargeLevel > 0) {
        chargeLevel *= 0.85; // Smooth decay
        if (chargeLevel < 0.05) chargeLevel = 0;
    }
}

// Legacy single function for backwards compatibility
function handleInput() {
    handleInputDown();
    // For simple tap, trigger aggressive after delay
    setTimeout(() => {
        if (isHolding && player.stance === 'idle' && phase === 1) {
            const holdDuration = performance.now() - holdStartTime;
            if (holdDuration < HOLD_THRESHOLD) {
                player.stance = 'aggressive';
                playSFX('attack');
                isHolding = false;
            }
        }
    }, DOUBLE_TAP_WINDOW);
}

// ============================================
// RENDERING
// ============================================
let floatingTexts = [];

function showText(text, x, y, color) {
    floatingTexts.push({ text, x, y, color, alpha: 1, vy: -2 });
}

// WarioWare-style big prompt
function showBigPrompt(text, color = '#ffffff') {
    bigPrompt = text;
    bigPromptColor = color;
    bigPromptScale = 1.5;
    bigPromptAlpha = 1;
}

function spawnParticles(x, y, count, color) {
    for (let i = 0; i < count; i++) {
        particles.push({
            x, y,
            vx: (Math.random() - 0.5) * 8,
            vy: (Math.random() - 0.5) * 8 - 3,
            life: 1,
            color
        });
    }
}

function drawBackground() {
    // Sunset gradient with beat pulse (more intense in fever mode)
    const pulseIntensity = beatPulse * (player.feverMode ? 0.3 : 0.15);
    const feverPulse = player.feverMode ? Math.sin(Date.now() / 100) * 0.15 : 0;

    const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
    if (player.feverMode) {
        // Purple/magenta fever palette
        gradient.addColorStop(0, `rgb(${255}, ${50 + pulseIntensity * 50}, ${150 + pulseIntensity * 50})`);
        gradient.addColorStop(0.4, `rgb(${200 + feverPulse * 55}, ${50 + pulseIntensity * 40}, ${180 + pulseIntensity * 40})`);
        gradient.addColorStop(0.7, `rgb(${150}, ${30 + pulseIntensity * 30}, ${150 + pulseIntensity * 30})`);
        gradient.addColorStop(1, '#1a0a1a');
    } else {
        // Normal sunset palette
        gradient.addColorStop(0, `rgb(${255}, ${107 + pulseIntensity * 50}, ${53 + pulseIntensity * 50})`);
        gradient.addColorStop(0.4, `rgb(${247}, ${147 + pulseIntensity * 40}, ${30 + pulseIntensity * 40})`);
        gradient.addColorStop(0.7, `rgb(${255}, ${68 + pulseIntensity * 30}, ${68 + pulseIntensity * 30})`);
        gradient.addColorStop(1, '#1a0a0a');
    }
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Beat pulse decay
    beatPulse *= 0.9;

    // Sun (pink in fever mode)
    ctx.fillStyle = player.feverMode ? '#ff66ff' : '#ffdd44';
    ctx.beginPath();
    ctx.arc(canvas.width - 80, 60, 40 + (player.feverMode ? Math.sin(Date.now() / 80) * 5 : 0), 0, Math.PI * 2);
    ctx.fill();

    // Fever sparkle particles
    if (player.feverMode && Math.random() < 0.3) {
        particles.push({
            x: Math.random() * canvas.width,
            y: Math.random() * (canvas.height - 60),
            vx: (Math.random() - 0.5) * 2,
            vy: Math.random() * 2 + 1,
            life: 0.8,
            color: Math.random() > 0.5 ? '#ff00ff' : '#ffff00'
        });
    }

    // Silhouette mountains
    ctx.fillStyle = '#0a0505';
    ctx.beginPath();
    ctx.moveTo(0, canvas.height);
    ctx.lineTo(50, canvas.height - 60);
    ctx.lineTo(120, canvas.height - 30);
    ctx.lineTo(180, canvas.height - 80);
    ctx.lineTo(250, canvas.height - 40);
    ctx.lineTo(320, canvas.height - 90);
    ctx.lineTo(400, canvas.height - 50);
    ctx.lineTo(canvas.width, canvas.height);
    ctx.fill();

    // Ground
    ctx.fillStyle = '#0f0808';
    ctx.fillRect(0, canvas.height - 40, canvas.width, 40);
}

function drawWarrior() {
    const x = 60;
    const y = canvas.height - 45;

    // SQUASH & STRETCH based on stance
    let squashX = 1, squashY = 1;
    if (player.stance === 'aggressive') {
        // Stretch forward on attack
        squashX = 1.15;
        squashY = 0.9;
    } else if (player.stance === 'defensive') {
        // Squash down on block
        squashX = 1.1;
        squashY = 0.85;
    } else if (player.stance === 'stumble') {
        // Wobbly on stumble
        squashX = 0.85 + Math.sin(Date.now() / 50) * 0.1;
        squashY = 1.1;
    }

    // Apply squash/stretch transform
    ctx.save();
    ctx.translate(x, y);
    ctx.scale(squashX, squashY);
    ctx.translate(-x, -y);

    // Charge glow effect
    if (chargeLevel > 0 || player.stance === 'charge') {
        const glowIntensity = player.stance === 'charge' ? 1 : chargeLevel;
        ctx.fillStyle = `rgba(68, 136, 255, ${glowIntensity * 0.5})`;
        ctx.beginPath();
        ctx.arc(x, y - 30, 30 + glowIntensity * 15, 0, Math.PI * 2);
        ctx.fill();

        // Charge particles
        if (Math.random() < glowIntensity * 0.5) {
            particles.push({
                x: x + (Math.random() - 0.5) * 30,
                y: y - 20 - Math.random() * 40,
                vx: (Math.random() - 0.5) * 2,
                vy: -Math.random() * 3 - 1,
                life: 0.8,
                color: '#4488ff'
            });
        }
    }

    ctx.fillStyle = '#000000';

    // Body (simple silhouette) - scale up when charging
    const scale = 1 + chargeLevel * 0.15;
    ctx.beginPath();
    ctx.ellipse(x, y - 20, 12 * scale, 20 * scale, 0, 0, Math.PI * 2);
    ctx.fill();

    // Head
    ctx.beginPath();
    ctx.arc(x, y - 48 - chargeLevel * 5, 10 * scale, 0, Math.PI * 2);
    ctx.fill();

    // Eyes (expressive!)
    ctx.fillStyle = player.stance === 'charge' ? '#4488ff' : '#ffffff';
    const eyeOffsetX = player.stance === 'aggressive' ? 2 : (player.stance === 'charge' ? 1 : 0);
    const eyeY = y - 50 - chargeLevel * 5;
    ctx.beginPath();
    ctx.arc(x - 3 + eyeOffsetX, eyeY, 4, 0, Math.PI * 2);
    ctx.arc(x + 5 + eyeOffsetX, eyeY, 4, 0, Math.PI * 2);
    ctx.fill();

    // Pupils (intense when charging)
    ctx.fillStyle = player.stance === 'charge' ? '#ffffff' : '#000000';
    ctx.beginPath();
    ctx.arc(x - 2 + eyeOffsetX, eyeY, player.stance === 'charge' ? 1 : 2, 0, Math.PI * 2);
    ctx.arc(x + 6 + eyeOffsetX, eyeY, player.stance === 'charge' ? 1 : 2, 0, Math.PI * 2);
    ctx.fill();

    // Weapon/Shield based on stance
    ctx.fillStyle = '#222222';
    if (player.stance === 'aggressive') {
        // Sword raised
        ctx.save();
        ctx.translate(x + 15, y - 30);
        ctx.rotate(-0.5);
        ctx.fillRect(-2, -25, 4, 30);
        ctx.fillRect(-5, -25, 10, 5);
        ctx.restore();
    } else if (player.stance === 'defensive') {
        // Shield up
        ctx.beginPath();
        ctx.ellipse(x + 20, y - 25, 15, 20, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#444444';
        ctx.lineWidth = 2;
        ctx.stroke();
    } else if (player.stance === 'charge' || chargeLevel > 0.3) {
        // Charged heavy weapon overhead
        ctx.fillStyle = chargeLevel > 0.8 || player.stance === 'charge' ? '#4488ff' : '#222222';
        ctx.save();
        ctx.translate(x, y - 55 - chargeLevel * 10);
        ctx.rotate(-0.2);
        // Heavy sword/hammer
        ctx.fillRect(-4, -20, 8, 35);
        ctx.fillRect(-10, -25, 20, 10);
        ctx.restore();
    } else {
        // Idle - sword down
        ctx.fillRect(x + 10, y - 20, 4, 25);
    }

    ctx.restore(); // End squash/stretch transform
}

function drawEnemy() {
    if (!enemy) return;

    const x = enemy.x;
    const y = enemy.y;

    // Glow effect behind enemy (colored by type)
    const glowColors = {
        swordsman: 'rgba(255,68,68,0.3)',
        archer: 'rgba(68,255,68,0.3)',
        armored: 'rgba(68,136,255,0.4)'
    };
    ctx.fillStyle = glowColors[enemy.type] || 'rgba(255,255,255,0.3)';
    ctx.beginPath();
    ctx.arc(x, y - 25, 35, 0, Math.PI * 2);
    ctx.fill();

    // Body silhouette (bigger)
    ctx.fillStyle = '#000000';
    ctx.beginPath();
    ctx.ellipse(x, y - 15, 14, 22, 0, 0, Math.PI * 2);
    ctx.fill();

    // Head
    ctx.beginPath();
    ctx.arc(x, y - 45, 12, 0, Math.PI * 2);
    ctx.fill();

    // Eyes (colored by type - BIGGER and more expressive)
    ctx.fillStyle = enemy.eyes;
    ctx.beginPath();
    ctx.arc(x - 4, y - 47, 5, 0, Math.PI * 2);
    ctx.arc(x + 4, y - 47, 5, 0, Math.PI * 2);
    ctx.fill();

    // Angry eyebrows
    ctx.strokeStyle = '#000000';
    ctx.lineWidth = 2;
    ctx.beginPath();
    if (enemy.type === 'swordsman') {
        // Angry V brows
        ctx.moveTo(x - 8, y - 55);
        ctx.lineTo(x - 2, y - 52);
        ctx.moveTo(x + 8, y - 55);
        ctx.lineTo(x + 2, y - 52);
    }
    ctx.stroke();

    // Weapon indicator (BIGGER and clearer)
    if (enemy.weapon === 'sword') {
        ctx.fillStyle = '#444444';
        ctx.save();
        ctx.translate(x - 18, y - 25);
        ctx.rotate(0.4);
        ctx.fillRect(-3, -30, 6, 40);
        // Crossguard
        ctx.fillRect(-10, -5, 20, 6);
        ctx.restore();
    } else if (enemy.weapon === 'bow') {
        ctx.strokeStyle = '#444444';
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.arc(x - 20, y - 25, 18, -0.9, 0.9);
        ctx.stroke();
        // Bowstring
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(x - 20 + 18 * Math.cos(-0.9), y - 25 + 18 * Math.sin(-0.9));
        ctx.lineTo(x - 5, y - 25);
        ctx.lineTo(x - 20 + 18 * Math.cos(0.9), y - 25 + 18 * Math.sin(0.9));
        ctx.stroke();
        // Arrow
        ctx.fillStyle = '#444444';
        ctx.fillRect(x - 25, y - 27, 25, 4);
        // Arrowhead
        ctx.beginPath();
        ctx.moveTo(x, y - 25);
        ctx.lineTo(x - 8, y - 30);
        ctx.lineTo(x - 8, y - 20);
        ctx.fill();
    } else if (enemy.weapon === 'shield') {
        // Big shield in front
        ctx.fillStyle = '#3366aa';
        ctx.beginPath();
        ctx.ellipse(x - 10, y - 20, 18, 25, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#224488';
        ctx.lineWidth = 3;
        ctx.stroke();
        // Shield boss (center decoration)
        ctx.fillStyle = '#4488cc';
        ctx.beginPath();
        ctx.arc(x - 10, y - 20, 6, 0, Math.PI * 2);
        ctx.fill();
        // Armor helmet spike
        ctx.fillStyle = '#444444';
        ctx.beginPath();
        ctx.moveTo(x, y - 60);
        ctx.lineTo(x - 5, y - 52);
        ctx.lineTo(x + 5, y - 52);
        ctx.fill();
    }

    // Stagger indicator
    if (enemy.staggered) {
        ctx.fillStyle = '#ffff00';
        ctx.font = 'bold 16px monospace';
        ctx.textAlign = 'center';
        ctx.fillText('DIZZY', x, y - 70);
        ctx.textAlign = 'left';
    }
}

function drawUI() {
    // Lives (hearts)
    for (let i = 0; i < 3; i++) {
        ctx.fillStyle = i < player.lives ? '#ff4444' : '#333333';
        ctx.beginPath();
        const hx = 20 + i * 25;
        const hy = 20;
        ctx.moveTo(hx, hy + 5);
        ctx.bezierCurveTo(hx, hy, hx - 8, hy, hx - 8, hy + 5);
        ctx.bezierCurveTo(hx - 8, hy + 10, hx, hy + 15, hx, hy + 18);
        ctx.bezierCurveTo(hx, hy + 15, hx + 8, hy + 10, hx + 8, hy + 5);
        ctx.bezierCurveTo(hx + 8, hy, hx, hy, hx, hy + 5);
        ctx.fill();
    }

    // Score
    ctx.fillStyle = '#ffffff';
    ctx.font = '16px monospace';
    ctx.textAlign = 'right';
    ctx.fillText(`${player.score}`, canvas.width - 10, 25);

    // BPM indicator (pulses with beat)
    ctx.fillStyle = `rgba(255, 255, 255, ${0.3 + beatPulse * 0.4})`;
    ctx.font = '10px monospace';
    ctx.fillText(`♪${Math.round(bpm)}`, 90, 20);

    // Combo (scales with combo count!)
    if (player.combo > 1) {
        const comboScale = Math.min(2.5, 1 + player.combo * 0.1);
        const fontSize = Math.floor(12 * comboScale);

        // Fever mode glow
        if (player.feverMode) {
            ctx.fillStyle = `rgba(255, 0, 255, ${0.3 + Math.sin(Date.now() / 100) * 0.2})`;
            ctx.beginPath();
            ctx.arc(canvas.width - 30, 38, 25 + Math.sin(Date.now() / 80) * 5, 0, Math.PI * 2);
            ctx.fill();
        } else if (player.combo >= 5) {
            // Fire glow at 5+
            ctx.fillStyle = `rgba(255, 100, 0, ${0.2 + Math.sin(Date.now() / 100) * 0.1})`;
            ctx.beginPath();
            ctx.arc(canvas.width - 30, 38, 20, 0, Math.PI * 2);
            ctx.fill();
        }

        ctx.fillStyle = player.feverMode ? '#ff00ff' : (player.combo >= 10 ? '#ff8800' : '#ffff00');
        ctx.font = `bold ${fontSize}px monospace`;
        ctx.fillText(`x${player.combo}`, canvas.width - 10, 42);

        // "FEVER!" label when in fever mode
        if (player.feverMode) {
            ctx.fillStyle = '#ff00ff';
            ctx.font = 'bold 10px monospace';
            ctx.fillText('FEVER!', canvas.width - 10, 55);
        }
    }

    // Tutorial hint for first few enemies (or when armored first appears)
    const showTutorial = (player.score < 400) || (enemy && enemy.type === 'armored' && player.score < 800);
    if (showTutorial && enemy && enemy.alive) {
        const colors = { swordsman: '#ff4444', archer: '#44ff44', armored: '#4488ff' };
        const markers = { swordsman: '1', archer: '2', armored: 'H' };

        ctx.fillStyle = 'rgba(0,0,0,0.8)';
        ctx.fillRect(canvas.width/2 - 90, 45, 180, 50);
        ctx.strokeStyle = colors[enemy.type];
        ctx.lineWidth = 2;
        ctx.strokeRect(canvas.width/2 - 90, 45, 180, 50);

        ctx.fillStyle = '#ffffff';
        ctx.font = '11px monospace';
        ctx.textAlign = 'center';

        if (enemy.type === 'swordsman') {
            ctx.fillText('SWORDSMAN [1] = TAP once', canvas.width/2, 63);
            ctx.fillStyle = '#ffff00';
            ctx.fillText('Quick tap when marker hits!', canvas.width/2, 82);
        } else if (enemy.type === 'archer') {
            ctx.fillText('ARCHER [2] = DOUBLE-TAP', canvas.width/2, 63);
            ctx.fillStyle = '#00ffff';
            ctx.fillText('Tap twice quickly!', canvas.width/2, 82);
        } else if (enemy.type === 'armored') {
            ctx.fillText('ARMORED [H] = HOLD', canvas.width/2, 63);
            ctx.fillStyle = '#4488ff';
            ctx.fillText('Hold until charge fills!', canvas.width/2, 82);
        }
    }

    ctx.textAlign = 'left';

    // GUITAR HERO STYLE BEAT TRACK
    const trackY = canvas.height - 35;
    const trackHeight = 30;

    // Track background
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    ctx.fillRect(0, trackY - trackHeight/2, canvas.width, trackHeight);

    // Hit zone (where you should press)
    const hitZoneWidth = 40;
    ctx.fillStyle = phase === 1 ? 'rgba(255,255,0,0.4)' : 'rgba(255,255,255,0.15)';
    ctx.fillRect(hitZoneX - hitZoneWidth/2, trackY - trackHeight/2, hitZoneWidth, trackHeight);

    // Hit zone border
    ctx.strokeStyle = phase === 1 ? '#ffff00' : '#666666';
    ctx.lineWidth = 2;
    ctx.strokeRect(hitZoneX - hitZoneWidth/2, trackY - trackHeight/2, hitZoneWidth, trackHeight);

    // "HIT" label
    ctx.fillStyle = phase === 1 ? '#ffff00' : '#666666';
    ctx.font = 'bold 10px monospace';
    ctx.textAlign = 'center';
    ctx.fillText('HIT', hitZoneX, trackY - trackHeight/2 - 5);

    // Show "waiting for double-tap" indicator
    const timeSinceLastTap = performance.now() - lastTapTime;
    if (lastTapTime > 0 && timeSinceLastTap < DOUBLE_TAP_WINDOW && !isHolding) {
        // Pulsing ring showing double-tap window
        const progress = timeSinceLastTap / DOUBLE_TAP_WINDOW;
        ctx.strokeStyle = `rgba(0, 255, 255, ${1 - progress})`;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(hitZoneX, trackY, 20 + progress * 10, 0, Math.PI * 2);
        ctx.stroke();

        ctx.fillStyle = '#00ffff';
        ctx.font = 'bold 8px monospace';
        ctx.fillText('TAP?', hitZoneX, trackY - trackHeight/2 - 15);
    }

    // Show charging progress in hit zone when holding
    if (isHolding && chargeLevel > 0) {
        // Charge fill bar
        ctx.fillStyle = `rgba(68, 136, 255, ${0.3 + chargeLevel * 0.5})`;
        ctx.fillRect(
            hitZoneX - hitZoneWidth/2,
            trackY + trackHeight/2 - chargeLevel * trackHeight,
            hitZoneWidth,
            chargeLevel * trackHeight
        );

        // Charge ring around hit zone
        ctx.strokeStyle = '#4488ff';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(hitZoneX, trackY, 18, -Math.PI/2, -Math.PI/2 + chargeLevel * Math.PI * 2);
        ctx.stroke();

        // "CHARGING" text
        if (chargeLevel < 1) {
            ctx.fillStyle = '#4488ff';
            ctx.font = 'bold 8px monospace';
            ctx.fillText('HOLD...', hitZoneX, trackY - trackHeight/2 - 15);
        } else {
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 10px monospace';
            ctx.fillText('READY!', hitZoneX, trackY - trackHeight/2 - 15);
        }
    }

    // Draw beat markers (scrolling toward hit zone)
    beatMarkers.forEach(marker => {
        // Skip rendering hit markers (they explode into particles)
        if (marker.hit) return;

        const colors = { aggressive: '#ffff00', defensive: '#00ffff', charge: '#4488ff' };
        const markerColor = colors[marker.type] || '#ffffff';
        const distToHit = Math.abs(marker.x - hitZoneX);
        const inHitZone = distToHit < 40;

        // HOLD marker: Draw tail first (behind the marker)
        if (marker.type === 'charge' && marker.tailLength) {
            // Shrink tail based on charge progress when holding in zone
            let displayTailLength = marker.tailLength;
            if (inHitZone && isHolding && chargeLevel > 0) {
                displayTailLength = marker.tailLength * (1 - chargeLevel);
            }
            const tailEnd = marker.x + displayTailLength;

            // Tail glow
            ctx.fillStyle = `rgba(68, 136, 255, 0.3)`;
            ctx.fillRect(marker.x, trackY - 8, displayTailLength, 16);

            // Tail body
            const gradient = ctx.createLinearGradient(marker.x, 0, tailEnd, 0);
            gradient.addColorStop(0, markerColor);
            gradient.addColorStop(1, `${markerColor}44`);
            ctx.fillStyle = gradient;
            ctx.fillRect(marker.x, trackY - 6, displayTailLength, 12);

            // Tail end cap (only if tail still visible)
            if (displayTailLength > 5) {
                ctx.fillStyle = `${markerColor}88`;
                ctx.beginPath();
                ctx.arc(tailEnd, trackY, 6, 0, Math.PI * 2);
                ctx.fill();
            }

            // Pulsing stripes on tail when holding in zone
            if (inHitZone && isHolding && displayTailLength > 10) {
                const stripeOffset = (Date.now() / 50) % 20;
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                for (let sx = marker.x + stripeOffset; sx < tailEnd; sx += 20) {
                    ctx.beginPath();
                    ctx.moveTo(sx, trackY - 5);
                    ctx.lineTo(sx, trackY + 5);
                    ctx.stroke();
                }
            }

            // Show consumed portion with bright flash
            if (inHitZone && isHolding && chargeLevel > 0) {
                const consumedStart = marker.x + displayTailLength;
                const consumedEnd = marker.x + marker.tailLength;
                ctx.fillStyle = `rgba(255, 255, 255, ${0.3 + Math.sin(Date.now() / 30) * 0.2})`;
                ctx.fillRect(consumedStart, trackY - 4, consumedEnd - consumedStart, 8);
            }
        }

        // Approaching glow (gets brighter near hit zone)
        if (distToHit < 80) {
            const glowIntensity = 1 - (distToHit / 80);
            ctx.fillStyle = `rgba(255, 255, 255, ${glowIntensity * 0.4})`;
            ctx.beginPath();
            ctx.arc(marker.x, trackY, 22 + glowIntensity * 15, 0, Math.PI * 2);
            ctx.fill();
        }

        // Pulsing effect when in hit zone
        const pulseSize = inHitZone ? Math.sin(Date.now() / 50) * 4 : 0;
        const baseSize = 16; // Bigger markers for clarity

        // Marker circle (bigger)
        ctx.fillStyle = markerColor;
        ctx.beginPath();
        ctx.arc(marker.x, trackY, baseSize + pulseSize, 0, Math.PI * 2);
        ctx.fill();

        // Marker border (thicker when in zone)
        ctx.strokeStyle = inHitZone ? '#ffffff' : '#888888';
        ctx.lineWidth = inHitZone ? 4 : 2;
        ctx.stroke();

        // Marker symbol - BIGGER and clearer
        ctx.fillStyle = '#000000';
        ctx.font = `bold ${inHitZone ? 18 : 16}px monospace`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        if (marker.type === 'aggressive') {
            ctx.fillText('!', marker.x, trackY); // "!" for single tap
        } else if (marker.type === 'defensive') {
            // Show "1" on first marker, "2" on second
            ctx.fillText(marker.isSecond ? '2' : '1', marker.x, trackY);
        } else if (marker.type === 'charge') {
            ctx.fillText('H', marker.x, trackY); // "H" for hold
        }
        ctx.textBaseline = 'alphabetic';

        // Action label above marker when approaching
        if (distToHit < 100 && distToHit > 40) {
            ctx.fillStyle = markerColor;
            ctx.font = 'bold 10px monospace';
            const label = marker.type === 'aggressive' ? 'TAP' :
                          marker.type === 'defensive' ? 'DBL' : 'HOLD';
            ctx.fillText(label, marker.x, trackY - baseSize - 8);
        }

        // Connect double-tap markers with a line
        if (marker.type === 'defensive' && !marker.isSecond) {
            // Find the second marker
            const secondMarker = beatMarkers.find(m =>
                m.type === 'defensive' && m.isSecond && !m.hit &&
                Math.abs(m.x - marker.x) < 50
            );
            if (secondMarker) {
                ctx.strokeStyle = `${markerColor}88`;
                ctx.lineWidth = 3;
                ctx.setLineDash([4, 4]);
                ctx.beginPath();
                ctx.moveTo(marker.x + 14, trackY);
                ctx.lineTo(secondMarker.x - 14, trackY);
                ctx.stroke();
                ctx.setLineDash([]);
            }
        }
    });

    // Beat tick marks on track
    for (let i = 0; i < 8; i++) {
        const tickX = hitZoneX + (i - 1) * 50;
        if (tickX > 0 && tickX < canvas.width) {
            ctx.strokeStyle = '#444444';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(tickX, trackY - 10);
            ctx.lineTo(tickX, trackY + 10);
            ctx.stroke();
        }
    }

    ctx.textAlign = 'left';
}

function drawEffects() {
    // Screen flash
    if (flashAlpha > 0) {
        ctx.fillStyle = flashColor;
        ctx.globalAlpha = flashAlpha;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.globalAlpha = 1;
        flashAlpha -= 0.05;
    }

    // BIG WARIOWARE-STYLE PROMPT
    if (bigPromptAlpha > 0) {
        ctx.save();
        ctx.globalAlpha = bigPromptAlpha;
        ctx.fillStyle = bigPromptColor;
        ctx.font = `bold ${Math.floor(36 * bigPromptScale)}px monospace`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        // Draw shadow
        ctx.fillStyle = '#000000';
        ctx.fillText(bigPrompt, canvas.width/2 + 3, canvas.height/2 - 20 + 3);

        // Draw text
        ctx.fillStyle = bigPromptColor;
        ctx.fillText(bigPrompt, canvas.width/2, canvas.height/2 - 20);

        ctx.restore();

        // Animate
        bigPromptScale = Math.max(1, bigPromptScale - 0.03);
        bigPromptAlpha -= 0.015;
    }

    // Particles
    particles.forEach((p, i) => {
        ctx.fillStyle = p.color;
        ctx.globalAlpha = p.life;
        ctx.fillRect(p.x - 2, p.y - 2, 4, 4);
        ctx.globalAlpha = 1;

        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.3; // gravity
        p.life -= 0.03;

        if (p.life <= 0) particles.splice(i, 1);
    });

    // Floating text
    floatingTexts.forEach((t, i) => {
        ctx.fillStyle = t.color;
        ctx.globalAlpha = t.alpha;
        ctx.font = 'bold 14px monospace';
        ctx.textAlign = 'center';
        ctx.fillText(t.text, t.x, t.y);
        ctx.textAlign = 'left';
        ctx.globalAlpha = 1;

        t.y += t.vy;
        t.alpha -= 0.02;

        if (t.alpha <= 0) floatingTexts.splice(i, 1);
    });
}

// CRT SCANLINES + RETRO EFFECTS
function drawCRT() {
    // Scanlines
    ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
    for (let y = 0; y < canvas.height; y += 3) {
        ctx.fillRect(0, y, canvas.width, 1);
    }

    // Subtle vignette
    const vignette = ctx.createRadialGradient(
        canvas.width/2, canvas.height/2, canvas.height * 0.3,
        canvas.width/2, canvas.height/2, canvas.height * 0.8
    );
    vignette.addColorStop(0, 'rgba(0,0,0,0)');
    vignette.addColorStop(1, 'rgba(0,0,0,0.4)');
    ctx.fillStyle = vignette;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Chromatic aberration on hits
    if (chromaOffset > 0.5) {
        ctx.globalCompositeOperation = 'screen';
        ctx.globalAlpha = chromaOffset * 0.15;
        ctx.fillStyle = '#ff0000';
        ctx.fillRect(-chromaOffset, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#00ffff';
        ctx.fillRect(chromaOffset, 0, canvas.width, canvas.height);
        ctx.globalCompositeOperation = 'source-over';
        ctx.globalAlpha = 1;
    }
    chromaOffset *= 0.85;
}

// COMBO MILESTONE CELEBRATION
function checkComboMilestone() {
    const milestones = [5, 10, 15, 20, 25, 30, 50];
    for (const m of milestones) {
        if (player.combo >= m && lastComboMilestone < m) {
            lastComboMilestone = m;
            comboMilestone = 1;

            // Big celebration!
            showBigPrompt(`${m} COMBO!`, m >= 20 ? '#ff00ff' : (m >= 10 ? '#ff8800' : '#ffff00'));
            screenShake = m >= 20 ? 15 : (m >= 10 ? 10 : 5);

            // Burst of particles
            for (let i = 0; i < m; i++) {
                particles.push({
                    x: canvas.width / 2 + (Math.random() - 0.5) * 100,
                    y: canvas.height / 2,
                    vx: (Math.random() - 0.5) * 15,
                    vy: (Math.random() - 0.5) * 15 - 5,
                    life: 1.2,
                    color: ['#ff00ff', '#ffff00', '#00ffff', '#ff8800'][Math.floor(Math.random() * 4)]
                });
            }

            // Special SFX for big milestones
            if (m >= 10) playSFX('fever');
            break;
        }
    }

    // Reset milestone tracker when combo resets
    if (player.combo === 0) lastComboMilestone = 0;
}

function drawGameOver() {
    ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.fillStyle = '#ff4444';
    ctx.font = 'bold 24px monospace';
    ctx.textAlign = 'center';
    ctx.fillText('GAME OVER', canvas.width/2, canvas.height/2 - 40);

    ctx.fillStyle = '#ffffff';
    ctx.font = '16px monospace';
    ctx.fillText(`Score: ${player.score}`, canvas.width/2, canvas.height/2);

    // High score
    const isNewHighScore = player.score > highScore;
    if (isNewHighScore) {
        ctx.fillStyle = '#ffff00';
        ctx.font = 'bold 14px monospace';
        ctx.fillText('NEW HIGH SCORE!', canvas.width/2, canvas.height/2 + 25);
    } else {
        ctx.fillStyle = '#888888';
        ctx.font = '12px monospace';
        ctx.fillText(`Best: ${highScore}`, canvas.width/2, canvas.height/2 + 25);
    }

    ctx.fillStyle = '#666666';
    ctx.font = '12px monospace';
    ctx.fillText('Tap to restart', canvas.width/2, canvas.height/2 + 55);

    ctx.textAlign = 'left';
}

// ============================================
// GAME LOOP
// ============================================
function update() {
    if (gameState !== 'playing') return;

    // Update charge state
    updateCharge();

    // Move enemy toward target
    if (enemy && enemy.x > enemy.targetX) {
        enemy.x -= 3;
    }

    // Update beat markers - move toward hit zone
    // Marker travels from right edge (420) to hit zone (80) = 340px in 1 beat
    // framesPerBeat = 60fps * (60/bpm seconds per beat) = 3600/bpm
    // speed = distance / frames = 340 / (3600/bpm) = 340 * bpm / 3600
    const markerSpeed = (340 * bpm) / 3600;
    beatMarkers.forEach(marker => {
        marker.x -= markerSpeed;
    });

    // Remove markers that have passed or been hit
    beatMarkers = beatMarkers.filter(m => m.x > -50 && !m.hit);

    // Screen shake decay
    if (screenShake > 0) screenShake *= 0.9;
}

function render() {
    // HIT-STOP: Skip rendering during freeze frames for impact
    if (hitStop > 0) {
        hitStop--;
        // Still draw but with slight zoom for impact
        ctx.save();
        const zoomAmount = 1 + hitStop * 0.002;
        ctx.translate(canvas.width/2, canvas.height/2);
        ctx.scale(zoomAmount, zoomAmount);
        ctx.translate(-canvas.width/2, -canvas.height/2);
    } else {
        ctx.save();
    }

    // Apply screen shake
    if (screenShake > 0.5) {
        ctx.translate(
            (Math.random() - 0.5) * screenShake,
            (Math.random() - 0.5) * screenShake
        );
    }

    drawBackground();

    if (gameState === 'playing' || gameState === 'gameover') {
        drawWarrior();
        if (enemy && enemy.alive) drawEnemy();
        drawUI();
        drawEffects();
    }

    if (gameState === 'gameover') {
        drawGameOver();
    }

    ctx.restore();

    // CRT effects on top (outside transform)
    drawCRT();
}

// Beat scheduler - runs ahead of time to schedule audio
function schedulerTick() {
    if (!audioCtx || gameState !== 'playing') return;

    while (nextBeatTime < audioCtx.currentTime + 0.1) {
        scheduleBeat(currentBeat, nextBeatTime);

        // Advance phase on each beat
        advancePhase();

        currentBeat = (currentBeat + 1) % 4;
        if (currentBeat === 0) currentBar++;

        nextBeatTime += beatInterval;
    }
}

function advancePhase() {
    phase = currentBeat;

    switch (phase) {
        case 0: // Enemy appears
            player.stance = 'idle';
            if (!enemy || !enemy.alive) {
                spawnEnemy();
                // WarioWare-style enemy announcement
                if (enemy.type === 'swordsman') {
                    showBigPrompt('SWORDSMAN!', '#ff4444');
                } else if (enemy.type === 'archer') {
                    showBigPrompt('ARCHER!', '#44ff44');
                } else if (enemy.type === 'armored') {
                    showBigPrompt('ARMORED!', '#4488ff');
                }
            } else {
                // Enemy returning
                showBigPrompt('AGAIN!', '#ffaa00');
            }

            // Spawn beat marker(s) based on enemy type
            const markerType = enemy ? enemy.counter : 'aggressive';

            if (markerType === 'defensive') {
                // DOUBLE TAP: Two markers close together
                beatMarkers.push({
                    x: canvas.width + 50,
                    type: markerType,
                    hit: false,
                    isSecond: false
                });
                beatMarkers.push({
                    x: canvas.width + 20, // Second marker slightly behind
                    type: markerType,
                    hit: false,
                    isSecond: true
                });
            } else if (markerType === 'charge') {
                // HOLD: Long note with tail
                beatMarkers.push({
                    x: canvas.width + 20,
                    type: markerType,
                    hit: false,
                    tailLength: 80 // Length of the hold tail
                });
            } else {
                // SINGLE TAP: Normal marker
                beatMarkers.push({
                    x: canvas.width + 20,
                    type: markerType,
                    hit: false
                });
            }
            break;
        case 1: // Choose stance (input window)
            // Show control hint based on enemy type
            if (enemy && enemy.alive) {
                if (enemy.type === 'swordsman') {
                    showBigPrompt('TAP!', '#ffff00');
                } else if (enemy.type === 'archer') {
                    showBigPrompt('DOUBLE-TAP!', '#00ffff');
                } else if (enemy.type === 'armored') {
                    showBigPrompt('HOLD!', '#4488ff');
                }
            }
            break;
        case 2: // Clash
            if (player.stance === 'idle') {
                player.stance = 'stumble';
                showBigPrompt('TOO SLOW!', '#ff0000');
                playSFX('miss');
                // Miss particles burst from hit zone
                for (let i = 0; i < 10; i++) {
                    particles.push({
                        x: hitZoneX,
                        y: canvas.height - 35,
                        vx: (Math.random() - 0.5) * 8,
                        vy: (Math.random() - 0.5) * 8,
                        life: 0.6,
                        color: '#ff0000'
                    });
                }
            }
            resolveClash();

            // Check for fever mode activation
            if (player.combo >= 10 && !player.feverMode) {
                player.feverMode = true;
                playSFX('fever');
                showBigPrompt('FEVER MODE!', '#ff00ff');
                screenShake = 10;
                flashColor = '#ff00ff';
                flashAlpha = 0.6;
            }
            break;
        case 3: // Aftermath
            // Prepare for next round
            if (enemy && !enemy.alive) {
                enemy = null;
            }
            // Increase tempo over time (slower ramp)
            if (currentBar > 0 && currentBar % 12 === 0) {
                bpm = Math.min(bpm + 3, 100); // Slower increase, lower max
                beatInterval = 60 / bpm;
                showBigPrompt('TEMPO UP!', '#ff8800');
            }
            break;
    }
}

function gameLoop() {
    update();
    render();
    schedulerTick();
    requestAnimationFrame(gameLoop);
}

// ============================================
// INPUT EVENTS
// ============================================
function onInput() {
    if (gameState === 'title') {
        startGame();
    } else if (gameState === 'gameover') {
        resetGame();
    } else if (gameState === 'playing' && phase === 1) {
        handleInput();
    }
}

document.addEventListener('keydown', (e) => {
    if (e.code === 'Space' && !e.repeat) {
        e.preventDefault();
        if (gameState === 'title') {
            startGame();
        } else if (gameState === 'gameover') {
            resetGame();
        } else if (gameState === 'playing') {
            // Accept input during phase 0 (late), 1 (on time), or early phase 2
            // This gives a more forgiving window
            if (phase === 1 || phase === 0 || phase === 2) {
                handleInputDown();
            }
        }
    }
});

document.addEventListener('keyup', (e) => {
    if (e.code === 'Space') {
        e.preventDefault();
        if (gameState === 'playing') {
            handleInputUp();
        }
    }
});

canvas.addEventListener('mousedown', () => {
    if (gameState === 'title') {
        startGame();
    } else if (gameState === 'gameover') {
        resetGame();
    } else if (gameState === 'playing') {
        if (phase === 1 || phase === 0 || phase === 2) {
            handleInputDown();
        }
    }
});

canvas.addEventListener('mouseup', () => {
    if (gameState === 'playing') {
        handleInputUp();
    }
});

canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    if (gameState === 'title') {
        startGame();
    } else if (gameState === 'gameover') {
        resetGame();
    } else if (gameState === 'playing') {
        if (phase === 1 || phase === 0 || phase === 2) {
            handleInputDown();
        }
    }
});

canvas.addEventListener('touchend', (e) => {
    e.preventDefault();
    if (gameState === 'playing') {
        handleInputUp();
    }
});

// Start overlay click handler (overlay blocks canvas clicks on title screen)
startOverlay.addEventListener('click', () => {
    if (gameState === 'title') {
        startGame();
    }
});

startOverlay.addEventListener('touchstart', (e) => {
    e.preventDefault();
    if (gameState === 'title') {
        startGame();
    }
});

// ============================================
// GAME CONTROL
// ============================================
function startGame() {
    initAudio();
    startOverlay.classList.add('hidden');
    gameState = 'playing';
    nextBeatTime = audioCtx.currentTime + 0.1;
    currentBeat = 0;
    currentBar = 0;
    phase = 0;
}

function resetGame() {
    player.lives = 3;
    player.score = 0;
    player.combo = 0;
    player.stance = 'idle';
    player.hasSeenArmored = false;
    player.feverMode = false;
    enemy = null;
    bpm = 52; // Start slow
    beatInterval = 60 / bpm;
    particles = [];
    floatingTexts = [];
    beatMarkers = [];
    screenShake = 0;
    flashAlpha = 0;
    chargeLevel = 0;
    isHolding = false;
    gameState = 'playing';
    nextBeatTime = audioCtx.currentTime + 0.1;
    currentBeat = 0;
    currentBar = 0;
    phase = 0;
}

// Start the game loop
gameLoop();

    </script>
</body>
</html>
